"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createOidc = exports.OidcInitializationError = void 0;
var oidc_client_ts_1 = require("oidc-client-ts");
var id_1 = require("tsafe/id");
var readExpirationTimeInJwt_1 = require("./tools/readExpirationTimeInJwt");
var assert_1 = require("tsafe/assert");
var urlQueryParams_1 = require("./tools/urlQueryParams");
var fnv1aHashToHex_1 = require("./tools/fnv1aHashToHex");
var Deferred_1 = require("./tools/Deferred");
var decodeJwt_1 = require("./tools/decodeJwt");
var getDownlinkAndRtt_1 = require("./tools/getDownlinkAndRtt");
var OidcInitializationError = /** @class */ (function (_super) {
    __extends(OidcInitializationError, _super);
    function OidcInitializationError(params) {
        var _newTarget = this.constructor;
        var _this = _super.call(this, (function () {
            switch (params.type) {
                case "server down":
                    return "The OIDC server is down";
                case "bad configuration":
                    return "Bad configuration. Timed out after ".concat(params.timeoutDelayMs, "ms");
                case "unknown":
                    return params.cause.message;
            }
        })(), 
        // @ts-expect-error
        { "cause": params.type === "unknown" ? params.cause : undefined }) || this;
        _this.type = params.type;
        Object.setPrototypeOf(_this, _newTarget.prototype);
        return _this;
    }
    return OidcInitializationError;
}(Error));
exports.OidcInitializationError = OidcInitializationError;
var paramsToRetrieveFromSuccessfulLogin = ["code", "state", "session_state", "iss"];
/** @see: https://github.com/garronej/oidc-spa#option-1-usage-without-involving-the-ui-framework */
function createOidc(params) {
    return __awaiter(this, void 0, void 0, function () {
        var issuerUri, clientId, clientSecret, _a, transformUrlBeforeRedirect, extraQueryParamsOrGetter, publicUrl_params, decodedIdTokenSchema, getExtraQueryParams, publicUrl, configHash, configHashKey, oidcClientTsUserManager, lastPublicRoute, realPushState_1, hasLoginBeenCalled, login, initialTokens, common, error, initializationError, currentTokens, onTokenChanges, oidc;
        var _this = this;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    issuerUri = params.issuerUri, clientId = params.clientId, clientSecret = params.clientSecret, _a = params.transformUrlBeforeRedirect, transformUrlBeforeRedirect = _a === void 0 ? function (url) { return url; } : _a, extraQueryParamsOrGetter = params.extraQueryParams, publicUrl_params = params.publicUrl, decodedIdTokenSchema = params.decodedIdTokenSchema;
                    getExtraQueryParams = (function () {
                        if (typeof extraQueryParamsOrGetter === "function") {
                            return extraQueryParamsOrGetter;
                        }
                        if (extraQueryParamsOrGetter !== undefined) {
                            return function () { return extraQueryParamsOrGetter; };
                        }
                        return undefined;
                    })();
                    publicUrl = (function () {
                        if (publicUrl_params === undefined) {
                            return window.location.origin;
                        }
                        return (publicUrl_params.startsWith("http")
                            ? publicUrl_params
                            : "".concat(window.location.origin).concat(publicUrl_params)).replace(/\/$/, "");
                    })();
                    configHash = (0, fnv1aHashToHex_1.fnv1aHashToHex)("".concat(issuerUri, " ").concat(clientId));
                    configHashKey = "configHash";
                    oidcClientTsUserManager = new oidc_client_ts_1.UserManager({
                        "authority": issuerUri,
                        "client_id": clientId,
                        "client_secret": clientSecret,
                        "redirect_uri": "" /* provided when calling login */,
                        "response_type": "code",
                        "scope": "openid profile",
                        "automaticSilentRenew": false,
                        "silent_redirect_uri": "".concat(publicUrl, "/silent-sso.html?").concat(configHashKey, "=").concat(configHash)
                    });
                    lastPublicRoute = undefined;
                    {
                        realPushState_1 = history.pushState.bind(history);
                        history.pushState = function pushState() {
                            var args = [];
                            for (var _i = 0; _i < arguments.length; _i++) {
                                args[_i] = arguments[_i];
                            }
                            lastPublicRoute = window.location.href;
                            return realPushState_1.apply(void 0, __spreadArray([], __read(args), false));
                        };
                    }
                    hasLoginBeenCalled = false;
                    login = function (_a) {
                        var doesCurrentHrefRequiresAuth = _a.doesCurrentHrefRequiresAuth, extraQueryParams = _a.extraQueryParams;
                        return __awaiter(_this, void 0, void 0, function () {
                            function URL() {
                                var args = [];
                                for (var _i = 0; _i < arguments.length; _i++) {
                                    args[_i] = arguments[_i];
                                }
                                var urlInstance = new (URL_real.bind.apply(URL_real, __spreadArray([void 0], __read(args), false)))();
                                return new Proxy(urlInstance, {
                                    "get": function (target, prop) {
                                        if (prop === "href") {
                                            var url_1 = urlInstance.href;
                                            Object.entries(__assign(__assign({}, getExtraQueryParams === null || getExtraQueryParams === void 0 ? void 0 : getExtraQueryParams()), extraQueryParams)).forEach(function (_a) {
                                                var _b = __read(_a, 2), name = _b[0], value = _b[1];
                                                return (url_1 = (0, urlQueryParams_1.addQueryParamToUrl)({
                                                    url: url_1,
                                                    name: name,
                                                    value: value
                                                }).newUrl);
                                            });
                                            url_1 = transformUrlBeforeRedirect(url_1);
                                            return url_1;
                                        }
                                        //@ts-expect-error
                                        return target[prop];
                                    }
                                });
                            }
                            var URL_real, redirect_uri, callback_1;
                            return __generator(this, function (_b) {
                                switch (_b.label) {
                                    case 0:
                                        //NOTE: We know there is a extraQueryParameter option but it doesn't allow
                                        // to control the encoding so we have to highjack global URL Class that is
                                        // used internally by oidc-client-ts. It's save to do so since this is the
                                        // last thing that will be done before the redirect.
                                        if (hasLoginBeenCalled) {
                                            return [2 /*return*/, new Promise(function () { })];
                                        }
                                        hasLoginBeenCalled = true;
                                        URL_real = window.URL;
                                        Object.defineProperty(window, "URL", { "value": URL });
                                        redirect_uri = (0, urlQueryParams_1.addQueryParamToUrl)({
                                            "url": window.location.href,
                                            "name": configHashKey,
                                            "value": configHash
                                        }).newUrl;
                                        if (doesCurrentHrefRequiresAuth) {
                                            callback_1 = function () {
                                                if (document.visibilityState === "visible") {
                                                    document.removeEventListener("visibilitychange", callback_1);
                                                    if (lastPublicRoute !== undefined) {
                                                        window.location.href = lastPublicRoute;
                                                    }
                                                    else {
                                                        window.history.back();
                                                    }
                                                }
                                            };
                                            document.addEventListener("visibilitychange", callback_1);
                                        }
                                        return [4 /*yield*/, oidcClientTsUserManager.signinRedirect({
                                                redirect_uri: redirect_uri,
                                                "redirectMethod": doesCurrentHrefRequiresAuth ? "replace" : "assign"
                                            })];
                                    case 1:
                                        _b.sent();
                                        return [2 /*return*/, new Promise(function () { })];
                                }
                            });
                        });
                    };
                    return [4 /*yield*/, (function getUser() {
                            return __awaiter(this, void 0, void 0, function () {
                                var url, result, result, loginSuccessUrl, paramsToRetrieveFromSuccessfulLogin_1, paramsToRetrieveFromSuccessfulLogin_1_1, name_1, result, oidcClientTsUser, _a, oidcClientTsUser, error_1, dLoginSuccessUrl_1, timeoutDelayMs_1, timeout_1, listener_1, loginSuccessUrl, oidcClientTsUser;
                                var e_1, _b;
                                return __generator(this, function (_c) {
                                    switch (_c.label) {
                                        case 0:
                                            url = window.location.href;
                                            {
                                                result = (0, urlQueryParams_1.retrieveQueryParamFromUrl)({ "name": configHashKey, url: url });
                                                if (!result.wasPresent || result.value !== configHash) {
                                                    return [3 /*break*/, 5];
                                                }
                                                url = result.newUrl;
                                            }
                                            {
                                                result = (0, urlQueryParams_1.retrieveQueryParamFromUrl)({ "name": "error", url: url });
                                                if (result.wasPresent) {
                                                    throw new Error("OIDC error: ".concat(result.value));
                                                }
                                            }
                                            loginSuccessUrl = "https://dummy.com";
                                            try {
                                                for (paramsToRetrieveFromSuccessfulLogin_1 = __values(paramsToRetrieveFromSuccessfulLogin), paramsToRetrieveFromSuccessfulLogin_1_1 = paramsToRetrieveFromSuccessfulLogin_1.next(); !paramsToRetrieveFromSuccessfulLogin_1_1.done; paramsToRetrieveFromSuccessfulLogin_1_1 = paramsToRetrieveFromSuccessfulLogin_1.next()) {
                                                    name_1 = paramsToRetrieveFromSuccessfulLogin_1_1.value;
                                                    result = (0, urlQueryParams_1.retrieveQueryParamFromUrl)({ name: name_1, url: url });
                                                    if (!result.wasPresent) {
                                                        if (name_1 === "iss") {
                                                            continue;
                                                        }
                                                        throw new Error("Missing query param: ".concat(name_1));
                                                    }
                                                    loginSuccessUrl = (0, urlQueryParams_1.addQueryParamToUrl)({
                                                        "url": loginSuccessUrl,
                                                        "name": name_1,
                                                        "value": result.value
                                                    }).newUrl;
                                                    url = result.newUrl;
                                                }
                                            }
                                            catch (e_1_1) { e_1 = { error: e_1_1 }; }
                                            finally {
                                                try {
                                                    if (paramsToRetrieveFromSuccessfulLogin_1_1 && !paramsToRetrieveFromSuccessfulLogin_1_1.done && (_b = paramsToRetrieveFromSuccessfulLogin_1.return)) _b.call(paramsToRetrieveFromSuccessfulLogin_1);
                                                }
                                                finally { if (e_1) throw e_1.error; }
                                            }
                                            window.history.pushState(null, "", url);
                                            oidcClientTsUser = undefined;
                                            _c.label = 1;
                                        case 1:
                                            _c.trys.push([1, 3, , 4]);
                                            return [4 /*yield*/, oidcClientTsUserManager.signinRedirectCallback(loginSuccessUrl)];
                                        case 2:
                                            oidcClientTsUser = _c.sent();
                                            return [3 /*break*/, 4];
                                        case 3:
                                            _a = _c.sent();
                                            //NOTE: The user has likely pressed the back button just after logging in.
                                            return [2 /*return*/, undefined];
                                        case 4: return [2 /*return*/, oidcClientTsUser];
                                        case 5: return [4 /*yield*/, oidcClientTsUserManager.getUser()];
                                        case 6:
                                            oidcClientTsUser = _c.sent();
                                            if (oidcClientTsUser === null) {
                                                return [3 /*break*/, 11];
                                            }
                                            _c.label = 7;
                                        case 7:
                                            _c.trys.push([7, 9, , 10]);
                                            return [4 /*yield*/, oidcClientTsUserManager.signinSilent()];
                                        case 8:
                                            _c.sent();
                                            return [3 /*break*/, 10];
                                        case 9:
                                            error_1 = _c.sent();
                                            (0, assert_1.assert)(error_1 instanceof Error);
                                            if (error_1.message === "Failed to fetch") {
                                                throw new OidcInitializationError({ "type": "server down" });
                                            }
                                            return [2 /*return*/, undefined];
                                        case 10: return [2 /*return*/, oidcClientTsUser];
                                        case 11:
                                            dLoginSuccessUrl_1 = new Deferred_1.Deferred();
                                            timeoutDelayMs_1 = (function () {
                                                var downlinkAndRtt = (0, getDownlinkAndRtt_1.getDownlinkAndRtt)();
                                                if (downlinkAndRtt === undefined) {
                                                    return 5000;
                                                }
                                                var downlink = downlinkAndRtt.downlink, rtt = downlinkAndRtt.rtt;
                                                // Base delay is the minimum delay we're willing to tolerate
                                                var baseDelay = 3000;
                                                // Calculate dynamic delay based on RTT and downlink
                                                // Add 1 to downlink to avoid division by zero
                                                var dynamicDelay = rtt * 2.5 + 3000 / (downlink + 1);
                                                return Math.max(baseDelay, dynamicDelay);
                                            })();
                                            timeout_1 = setTimeout(function () {
                                                return dLoginSuccessUrl_1.reject(new OidcInitializationError({
                                                    "type": "bad configuration",
                                                    timeoutDelayMs: timeoutDelayMs_1
                                                }));
                                            }, timeoutDelayMs_1);
                                            listener_1 = function (event) {
                                                var e_2, _a;
                                                if (typeof event.data !== "string") {
                                                    return;
                                                }
                                                var url = event.data;
                                                {
                                                    var result = void 0;
                                                    try {
                                                        result = (0, urlQueryParams_1.retrieveQueryParamFromUrl)({ "name": configHashKey, url: url });
                                                    }
                                                    catch (_b) {
                                                        // This could possibly happen if url is not a valid url.
                                                        return;
                                                    }
                                                    if (!result.wasPresent || result.value !== configHash) {
                                                        return;
                                                    }
                                                }
                                                clearTimeout(timeout_1);
                                                window.removeEventListener("message", listener_1);
                                                {
                                                    var result = (0, urlQueryParams_1.retrieveQueryParamFromUrl)({ "name": "error", url: url });
                                                    if (result.wasPresent) {
                                                        dLoginSuccessUrl_1.resolve(undefined);
                                                        return;
                                                    }
                                                }
                                                var loginSuccessUrl = "https://dummy.com";
                                                try {
                                                    for (var paramsToRetrieveFromSuccessfulLogin_2 = __values(paramsToRetrieveFromSuccessfulLogin), paramsToRetrieveFromSuccessfulLogin_2_1 = paramsToRetrieveFromSuccessfulLogin_2.next(); !paramsToRetrieveFromSuccessfulLogin_2_1.done; paramsToRetrieveFromSuccessfulLogin_2_1 = paramsToRetrieveFromSuccessfulLogin_2.next()) {
                                                        var name_2 = paramsToRetrieveFromSuccessfulLogin_2_1.value;
                                                        var result = (0, urlQueryParams_1.retrieveQueryParamFromUrl)({ name: name_2, url: url });
                                                        if (!result.wasPresent) {
                                                            if (name_2 === "iss") {
                                                                continue;
                                                            }
                                                            throw new Error("Missing query param: ".concat(name_2));
                                                        }
                                                        loginSuccessUrl = (0, urlQueryParams_1.addQueryParamToUrl)({
                                                            "url": loginSuccessUrl,
                                                            "name": name_2,
                                                            "value": result.value
                                                        }).newUrl;
                                                    }
                                                }
                                                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                                                finally {
                                                    try {
                                                        if (paramsToRetrieveFromSuccessfulLogin_2_1 && !paramsToRetrieveFromSuccessfulLogin_2_1.done && (_a = paramsToRetrieveFromSuccessfulLogin_2.return)) _a.call(paramsToRetrieveFromSuccessfulLogin_2);
                                                    }
                                                    finally { if (e_2) throw e_2.error; }
                                                }
                                                dLoginSuccessUrl_1.resolve(loginSuccessUrl);
                                            };
                                            window.addEventListener("message", listener_1, false);
                                            oidcClientTsUserManager
                                                .signinSilent({ "silentRequestTimeoutInSeconds": timeoutDelayMs_1 / 1000 })
                                                .catch(function (error) {
                                                if (error.message === "Failed to fetch") {
                                                    clearTimeout(timeout_1);
                                                    dLoginSuccessUrl_1.reject(new OidcInitializationError({ "type": "server down" }));
                                                }
                                            });
                                            return [4 /*yield*/, dLoginSuccessUrl_1.pr];
                                        case 12:
                                            loginSuccessUrl = _c.sent();
                                            if (loginSuccessUrl === undefined) {
                                                return [3 /*break*/, 14];
                                            }
                                            return [4 /*yield*/, oidcClientTsUserManager.signinRedirectCallback(loginSuccessUrl)];
                                        case 13:
                                            oidcClientTsUser = _c.sent();
                                            return [2 /*return*/, oidcClientTsUser];
                                        case 14: return [2 /*return*/, undefined];
                                    }
                                });
                            });
                        })().then(function (oidcClientTsUser) {
                            if (oidcClientTsUser === undefined) {
                                return undefined;
                            }
                            var tokens = oidcClientTsUserToTokens({
                                oidcClientTsUser: oidcClientTsUser,
                                decodedIdTokenSchema: decodedIdTokenSchema
                            });
                            if (tokens.refreshTokenExpirationTime < tokens.accessTokenExpirationTime) {
                                console.warn([
                                    "The OIDC refresh token shorter than the one of the access token.",
                                    "This is very unusual and probably a misconfiguration.",
                                    "Check your oidc server configuration for ".concat(clientId, " ").concat(issuerUri)
                                ].join(" "));
                            }
                            return tokens;
                        }, function (error) {
                            (0, assert_1.assert)(error instanceof Error);
                            return error;
                        })];
                case 1:
                    initialTokens = _b.sent();
                    common = {
                        "params": {
                            issuerUri: issuerUri,
                            clientId: clientId
                        }
                    };
                    if (initialTokens instanceof Error) {
                        error = initialTokens;
                        initializationError = error instanceof OidcInitializationError
                            ? error
                            : new OidcInitializationError({
                                "type": "unknown",
                                "cause": error
                            });
                        console.error("OIDC initilization error: ".concat(initializationError.message));
                        return [2 /*return*/, (0, id_1.id)(__assign(__assign({}, common), { "isUserLoggedIn": false, "login": function () { return __awaiter(_this, void 0, void 0, function () {
                                    return __generator(this, function (_a) {
                                        alert("Authentication is currently unavailable. Please try again later.");
                                        return [2 /*return*/, new Promise(function () { })];
                                    });
                                }); }, initializationError: initializationError }))];
                    }
                    if (initialTokens === undefined) {
                        return [2 /*return*/, (0, id_1.id)(__assign(__assign({}, common), { "isUserLoggedIn": false, login: login, "initializationError": undefined }))];
                    }
                    currentTokens = initialTokens;
                    onTokenChanges = new Set();
                    oidc = (0, id_1.id)(__assign(__assign({}, common), { "isUserLoggedIn": true, "getTokens": function () { return currentTokens; }, "logout": function (params) { return __awaiter(_this, void 0, void 0, function () {
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0: return [4 /*yield*/, oidcClientTsUserManager.signoutRedirect({
                                            "post_logout_redirect_uri": (function () {
                                                switch (params.redirectTo) {
                                                    case "current page":
                                                        return window.location.href;
                                                    case "home":
                                                        return publicUrl;
                                                    case "specific url":
                                                        return params.url;
                                                }
                                                (0, assert_1.assert)(false);
                                            })()
                                        })];
                                    case 1:
                                        _a.sent();
                                        return [2 /*return*/, new Promise(function () { })];
                                }
                            });
                        }); }, "renewTokens": function () { return __awaiter(_this, void 0, void 0, function () {
                            var oidcClientTsUser, decodedIdTokenPropertyDescriptor;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0: return [4 /*yield*/, oidcClientTsUserManager.signinSilent()];
                                    case 1:
                                        oidcClientTsUser = _a.sent();
                                        (0, assert_1.assert)(oidcClientTsUser !== null);
                                        decodedIdTokenPropertyDescriptor = Object.getOwnPropertyDescriptor(currentTokens, "decodedIdToken");
                                        (0, assert_1.assert)(decodedIdTokenPropertyDescriptor !== undefined);
                                        currentTokens = oidcClientTsUserToTokens({
                                            oidcClientTsUser: oidcClientTsUser,
                                            decodedIdTokenSchema: decodedIdTokenSchema
                                        });
                                        // NOTE: We do that to preserve the cache and the object reference.
                                        Object.defineProperty(currentTokens, "decodedIdToken", decodedIdTokenPropertyDescriptor);
                                        onTokenChanges.forEach(function (onTokenChange) { return onTokenChange(); });
                                        return [2 /*return*/];
                                }
                            });
                        }); }, "subscribeToTokensChange": function (onTokenChange) {
                            onTokenChanges.add(onTokenChange);
                            return {
                                "unsubscribe": function () {
                                    onTokenChanges.delete(onTokenChange);
                                }
                            };
                        } }));
                    (function scheduleAutomaticRenew() {
                        var _this = this;
                        var msBeforeExpiration = Math.min(currentTokens.accessTokenExpirationTime, currentTokens.refreshTokenExpirationTime) -
                            Date.now();
                        setTimeout(function () { return __awaiter(_this, void 0, void 0, function () {
                            var _a;
                            return __generator(this, function (_b) {
                                switch (_b.label) {
                                    case 0:
                                        _b.trys.push([0, 2, , 4]);
                                        return [4 /*yield*/, oidc.renewTokens()];
                                    case 1:
                                        _b.sent();
                                        return [3 /*break*/, 4];
                                    case 2:
                                        _a = _b.sent();
                                        return [4 /*yield*/, login({ "doesCurrentHrefRequiresAuth": true })];
                                    case 3:
                                        _b.sent();
                                        return [3 /*break*/, 4];
                                    case 4:
                                        scheduleAutomaticRenew();
                                        return [2 /*return*/];
                                }
                            });
                        }); }, msBeforeExpiration - /* min validity in seconds */ 25 * 1000);
                    })();
                    return [2 /*return*/, oidc];
            }
        });
    });
}
exports.createOidc = createOidc;
function oidcClientTsUserToTokens(params) {
    var oidcClientTsUser = params.oidcClientTsUser, decodedIdTokenSchema = params.decodedIdTokenSchema;
    var accessToken = oidcClientTsUser.access_token;
    var accessTokenExpirationTime = (function () {
        read_from_metadata: {
            var expires_at = oidcClientTsUser.expires_at;
            if (expires_at === undefined) {
                break read_from_metadata;
            }
            return expires_at * 1000;
        }
        read_from_jwt: {
            var expirationTime = (0, readExpirationTimeInJwt_1.readExpirationTimeInJwt)(accessToken);
            if (expirationTime === undefined) {
                break read_from_jwt;
            }
            return expirationTime;
        }
        (0, assert_1.assert)(false, "Failed to get access token expiration time");
    })();
    var refreshToken = oidcClientTsUser.refresh_token;
    (0, assert_1.assert)(refreshToken !== undefined, "No refresh token provided by the oidc server");
    var refreshTokenExpirationTime = (function () {
        read_from_jwt: {
            var expirationTime = (0, readExpirationTimeInJwt_1.readExpirationTimeInJwt)(refreshToken);
            if (expirationTime === undefined) {
                break read_from_jwt;
            }
            return expirationTime;
        }
        (0, assert_1.assert)(false, "Failed to get refresh token expiration time");
    })();
    var idToken = oidcClientTsUser.id_token;
    (0, assert_1.assert)(idToken !== undefined, "No id token provided by the oidc server");
    var tokens = {
        accessToken: accessToken,
        accessTokenExpirationTime: accessTokenExpirationTime,
        refreshToken: refreshToken,
        refreshTokenExpirationTime: refreshTokenExpirationTime,
        idToken: idToken,
        "decodedIdToken": null
    };
    var cache = undefined;
    Object.defineProperty(tokens, "decodedIdToken", {
        "get": function () {
            if (cache !== undefined && cache.idToken === this.idToken) {
                return cache.decodedIdToken;
            }
            var decodedIdToken = (0, decodeJwt_1.decodeJwt)(this.idToken);
            if (decodedIdTokenSchema !== undefined) {
                decodedIdToken = decodedIdTokenSchema.parse(decodedIdToken);
            }
            cache = {
                "idToken": this.idToken,
                decodedIdToken: decodedIdToken
            };
            return decodedIdToken;
        },
        "configurable": true,
        "enumerable": true
    });
    return tokens;
}
//# sourceMappingURL=oidc.js.map