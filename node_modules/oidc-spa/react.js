"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createReactOidc = void 0;
var jsx_runtime_1 = require("react/jsx-runtime");
var react_1 = require("react");
var oidc_1 = require("./oidc");
var assert_1 = require("tsafe/assert");
var id_1 = require("tsafe/id");
var useGuaranteedMemo_1 = require("./tools/powerhooks/useGuaranteedMemo");
var oidcContext = (0, react_1.createContext)(undefined);
/** @see: https://github.com/garronej/oidc-spa#option-2-usage-directly-within-react */
function createReactOidc(params) {
    var prOidc = (0, oidc_1.createOidc)(params);
    var decodedIdTokenSchema = params.decodedIdTokenSchema;
    function OidcProvider(props) {
        var children = props.children, fallback = props.fallback;
        var _a = __read((0, react_1.useState)(undefined), 2), oidc = _a[0], setOidc = _a[1];
        (0, react_1.useEffect)(function () {
            prOidc.then(setOidc);
        }, []);
        if (oidc === undefined) {
            return (0, jsx_runtime_1.jsx)(jsx_runtime_1.Fragment, { children: fallback === undefined ? null : fallback });
        }
        return ((0, jsx_runtime_1.jsx)(oidcContext.Provider, { value: { oidc: oidc, decodedIdTokenSchema: decodedIdTokenSchema }, children: children }));
    }
    function useOidc(params) {
        var _a = (params !== null && params !== void 0 ? params : {}).assertUserLoggedIn, assertUserLoggedIn = _a === void 0 ? false : _a;
        var _b = (function useClosure() {
            var context = (0, react_1.useContext)(oidcContext);
            (0, assert_1.assert)(context !== undefined, "You must use useOidc inside a OidcProvider");
            return context;
        })(), oidc = _b.oidc, decodedIdTokenSchema_context = _b.decodedIdTokenSchema;
        var _c = __read((0, react_1.useReducer)(function () { return []; }, []), 2), forceUpdate = _c[1];
        (0, react_1.useEffect)(function () {
            if (!oidc.isUserLoggedIn) {
                return;
            }
            var unsubscribe = oidc.subscribeToTokensChange(forceUpdate).unsubscribe;
            return unsubscribe;
        }, [oidc]);
        if (assertUserLoggedIn && !oidc.isUserLoggedIn) {
            throw new Error("The user must be logged in to use this hook (assertUserLoggedIn was set to true)");
        }
        var oidcTokens = (function useClosure() {
            var tokens = oidc.isUserLoggedIn ? oidc.getTokens() : undefined;
            var oidcTokens = (0, useGuaranteedMemo_1.useGuaranteedMemo)(function () {
                if (tokens === undefined) {
                    return undefined;
                }
                var oidcTokens = {
                    "accessToken": tokens.accessToken,
                    "accessTokenExpirationTime": tokens.accessTokenExpirationTime,
                    "idToken": tokens.idToken,
                    "refreshToken": tokens.refreshToken,
                    "refreshTokenExpirationTime": tokens.refreshTokenExpirationTime,
                    "decodedIdToken": null
                };
                var cache = undefined;
                Object.defineProperty(oidcTokens, "decodedIdToken", {
                    "get": function () {
                        if (cache !== undefined) {
                            return cache.decodedIdToken;
                        }
                        var decodedIdToken = tokens.decodedIdToken;
                        if (decodedIdTokenSchema !== undefined &&
                            decodedIdTokenSchema !== decodedIdTokenSchema_context) {
                            decodedIdToken = decodedIdTokenSchema.parse(decodedIdToken);
                        }
                        cache = { decodedIdToken: decodedIdToken };
                        return decodedIdToken;
                    }
                });
                return oidcTokens;
            }, [
                tokens === null || tokens === void 0 ? void 0 : tokens.accessToken,
                tokens === null || tokens === void 0 ? void 0 : tokens.accessTokenExpirationTime,
                tokens === null || tokens === void 0 ? void 0 : tokens.idToken,
                tokens === null || tokens === void 0 ? void 0 : tokens.refreshToken,
                tokens === null || tokens === void 0 ? void 0 : tokens.refreshTokenExpirationTime
            ]);
            return { oidcTokens: oidcTokens };
        })().oidcTokens;
        var common = {
            "params": oidc.params
        };
        return oidc.isUserLoggedIn
            ? (0, id_1.id)(((0, assert_1.assert)(oidcTokens !== undefined), __assign(__assign({}, common), { "isUserLoggedIn": true, oidcTokens: oidcTokens, "logout": oidc.logout, "renewTokens": oidc.renewTokens })))
            : (0, id_1.id)(__assign(__assign({}, common), { "isUserLoggedIn": false, "login": oidc.login, "initializationError": oidc.initializationError }));
    }
    return { OidcProvider: OidcProvider, useOidc: useOidc, prOidc: prOidc };
}
exports.createReactOidc = createReactOidc;
//# sourceMappingURL=react.js.map